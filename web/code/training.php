<?php
require_once('config.php');
require_once('common.php');
require_once('page.php');
require_once('problems.php');
require_once('db/brain.php');

class TrainingPage extends Page {
    public function getTitle() {
        return 'O(N)::Training';
    }

    private function initIMPL($position) {
        $brain = new Brain();
        $key = 'IMPL';
        $link = 'implementation';
        $title = 'Implementation';
        $summary = '
            Секцията покрива вход и изход от програма, работа с масиви и символни низове.
            Упражняват се лесни задачи, които изискват директна имплементация на описана процедура.
        ';
        $expanded = '
            В тази секция ще се научите как да четете и пишете стрингове, цели числа, числа с плаваща запетая, като
            част от входа и изхода на програма. Ще упражните да манипулирате масиви и символни низове ползвайки
            основните конструкции в програмните езици (if/else, for, while), а както и функции.
            <br><br>
            Подходящи теми, които можете да прочетете, са
            <a href="http://www.informatika.bg/lectures/io" target="_blank">Вход и изход от програма</a>,
            <a href="http://www.informatika.bg/lectures/variables-structs-arrays" target="_blank">Променливи, масиви,
            и структури</a>, и
            <a href="http://www.informatika.bg/lectures/search-and-iteration" target="_blank">Търсене и итерация</a>.
            <br><br>
            За тренировка сме ви подготвили лесни задачи, в повечето от които е казано директно какво се иска от вас да
            имплементирате - тоест просто трябва да превърнете описаната процедура в код.
        ';
        $problems = '2,157,134,155,181,184,15,43,194,199,106,214,164,234,236,238';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initCCAS($position) {
        $brain = new Brain();
        $key = 'CCAS';
        $title = 'Corner Cases';
        $link = 'corner-cases';
        $summary = '
            Секцията покрива задачи с относително лесно решение, в които обаче има някаква уловка,
            частни случаи, или нещо, което лесно може да се обърка при имплементацията.
        ';
        $expanded = '
            В тази секция ще разгледаме за какво да внимаваме, когато имплементираме дадена задача. Ще наблегнем на
            задачи с относително лесно решение, в които обаче има някакъв частен случай или уловка, който(ято) лесно
            може да бъде пропуснат(а). Такива задачи могат да струват много "скъпо" на състезателите в състезания,
            където за да се мине задачата се изисква правилно справяне с всички тестове (като например
            <a href="http://codeforces.com/" target="_blank">CodeForces</a>,
            <a href="https://www.topcoder.com/tc" target="_blank">TopCoder</a>, и
            <a href="https://icpc.baylor.edu/" target="_blank">ACM ICPC</a>).
            <br><br>
            Подходяща тема, която би ви помогнала да пишете по-чист код и така да избягвате потенциални проблеми е тази за
            <a href="http://www.informatika.bg/lectures/coding-conventions" target="_blank">Конвенции за стил на кода</a>.
            <br><br>
            Упражняват се лесни задачи, в които има частни случаи или нещо, което лесно може да се обърка при
            имплементацията. В темите по-нататък ще срещнете и други, по-сложни такива задачи.
        ';
        $problems = '119,195,144,171,191,95';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initRECU($position) {
        $brain = new Brain();
        $key = 'RECU';
        $link = 'recursion-and-backtrack';
        $title = 'Recursion & Backtrack';
        $summary = '
            Секцията покрива рекурсия и търсене с връщане, както и различни оптимизации, които могат да се приложат при
            тях (ред на извикване на под-задачите, рязане на рекурсията, и други).
        ';
        $expanded = '
            В тази секция ще разгледаме как да решаваме задачи с изчерпване, ползвайки рекурсия и търсене с връщане
            (backtrack). За някои от задачите ще ви се наложи да измислите оптимизации, за да бъде достатъчно бързо
            решението ви - например в какъв ред да извиквате под-задачите, кои клони на рекурсията нямат смисъл да
            бъдат обходени и могат да бъдат "изрязани" (наричано на Английски "pruning"), както и други.
            <br><br>
            Подходяща тема, която можете да прочетете е
            <a href="http://www.informatika.bg/lectures/recursion" target="_blank">Рекурсия и търсене с връщане</a>.
            <br><br>
            Упражняват се лесни до средно-трудни задачи, в които трябва да се имплементира рекурсивно решение.
            Задачата <a href="/problems/138">Schedule</a> с дадените ограничения може да се реши с бектрек, макар че
            има доста по-добро (полиномиално) решение, което ще разгледаме в секцията
            <a href="/training/greedy">Greedy</a>.
        ';
        $problems = '66,179,63,90,145,102,138';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initBRUT($position) {
        $brain = new Brain();
        $key = 'BRUT';
        $link = 'bruteforce';
        $title = 'Bruteforce';
        $summary = '
            Секцията покрива задачи, които се решават с "груба сила" - обикновено пълно изчерпване или поне изчерпване
            на част от задачата за опростяване на остатъка от нея, както и генериране на малките отговори за стигане до
            наблюдение.
        ';
        $expanded = '
            В тази секция ще разгледаме задачи, които или се решават изцяло с пълно изчерпване (но не backtrack), или
            или се ползва изчерпване на някаква част от задачата за да се опрости остатъка от нея. В много задачи не е
            нужно да се ползва изчерпване - съществува ефективен алгоритъм, който ги решава - но той е или труден или
            изисква разглеждането на много частни случаи. Понякога, ако ограниченията го позволяват, можем вместо това
            да обходим всички възможности за дадено нещо в задачата, като така или вече ни трябва значително по-прост
            алгоритъм за останалата част, или броя частни случаи намалява многократно.
            <br><br>
            Допълнително, в задачи (в които обикновено отговорът е едно единствено число), за които нямаме идея как да
            подходим, можем да напишем bruteforce решение за малките стойности, и да се опитаме да намерим някаква
            зависимост в отговорите: може да се окаже някаква редица или проста формула.
            <br><br>
            Последно, на състезания, в които нямаме feedback за изпратените от нас решения преди края (например
            <a href="http://codeforces.com/" target="_blank">CodeForces</a>,
            <a href="https://www.topcoder.com/tc" target="_blank">TopCoder</a>,
            <a href="https://icpc.baylor.edu/" target="_blank">ACM ICPC</a>,
            а също и някои задачи по ученически състезания), понякога е полезно да напишем bruteforce решение с което да
            тестваме "умното" ни такова. Обикновено така се откриват бъгове, като плюсът е, че имаме и тест, с който да
            ги дебъгваме (знаем верния отговор за него от брутфорс решението).
        ';
        $problems = '166,200,229,153,220,203,4,175,217';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initSORT($position) {
        $brain = new Brain();
        $key = 'SORT';
        $link = 'sorting';
        $title = 'Sorting';
        $summary = '
            Секцията покрива темата за сортиране - "бавни" (O(N<sup>2</sup>)) и "бързи" (O(N * log(N)) сортирания, както
            и сортирания, които не са базирани на сравнения (например counting sort).
        ';
        $expanded = '
            В тази секция ще разгледаме една от популярните теми в програмирането - а именно какво е сортиране и
            няколко стандартни алгоритми, които можем да ползваме. Ще разгледаме както "лесни" алгоритми със сложност
            O(N<sup>2</sup>), като например Bubble Sort, Selection Sort, Insertion Sort, така и ефективни
            такива (Quick Sort, Merge Sort, Heap Sort) със сложност O(N*log(N)). Ще видим и начини, по които можем да
            сортираме и за по-бързо (линейно) време, ползвайки Counting Sort.
            <br><br>
            Подходящи теми, които можете да прочетете, са тези за
            <a href="http://www.informatika.bg/lectures/sorting" target="_blank">Сортиране</a>,
            <a href="http://www.informatika.bg/lectures/fast-sorting-algorithms" target="_blank">Бързи сортирания</a>,
            а донякъде полезна тук би ви била и <a href="http://www.informatika.bg/lectures/STL" target="_blank">STL</a>.
            За да разберете как разделяме алгоритмите на "бавни" и "бързи" е много полезна и темата за
            <a href="http://www.informatika.bg/lectures/complexity" target="_blank">Сложност на алгоритми</a>.
            <br><br>
            Макар и да има лесно за ползване ефективно сортиране в STL, част от задачите в секцията са такива, че да
            трябва сами да имплементирате логиката на някои от сортиращите алгоритми.
        ';
        $problems = '123,127,215,132,221,45,182,222,128';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGRDY($position) {
        $brain = new Brain();
        $key = 'GRDY';
        $link = 'greedy';
        $title = 'Greedy';
        $summary = '
            Секцията покрива задачи, които могат да бъдат решени ползвайки алчна стратегия. Тук няма много теория, а
            по-скоро практика за да почнете да "надушвате" кога може да бъде подходено по този начин.
        ';
        $expanded = '
            В тази секция ще разгледаме как алчни стратегии понякога могат да бъдат приложени в състезателни задачи.
            Ще видим няколко популярни задачи, чието решение е базирано на greedy, и няколко по-оригинални, в които
            то е ключът към решението. За този тип задачи няма много теория, която може да ви помогне - основното е
            да почнете да познавате кога алчна стратегия може да бъде приложена и кога - не. За съжаление в много
            задачи само ще <em>изглежда</em>, че тя е възможна, но реално ще има случаи, в които няма да работи
            правилно. Повечето задачи, в които това е така, се решават с Динамично Оптимиране, което ще разгледаме
            малко по-късно.
            <br><br>
            Подходяща тема, която можете да разгледате, е тази за
            <a href="http://www.informatika.bg/lectures/greedy" target="_blank">Алчни стратегии</a>.
            <br><br>
            Една от известните задачи, базирани на алчна стратегия, вече разгледахме в секцията за сортиране - това
            беше задачата <a href="/problems/182">MaxNumber</a>.
            Друга доста "стандартна" е <a href="/problems/138">Schedule</a>, която с дадените ограничения може да бъде
            решена и с bruteforce, но съществува много по-ефективно алчно решение за нея. Донякъде известна задача от
            интервюта е <a href="/problems/55">Codes</a>. Останалите варират по сложност на алчното наблюдение, което
            трябва да направите - в някои то е много очевидно, докато в други съвсем не е!
        ';
        $problems = '143,165,206,170,72,58,178,190,230,138,81,112,120,218,223,67,208,55';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initMATH($position) {
        $brain = new Brain();
        $key = 'MATH';
        $link = 'math';
        $title = 'Math';
        $summary = '
            Секцията покрива относително прости математически похвати, които се срещат често в състезателни задачи.
            Голяма част от тях се учат в училище и са на ниво 5-6 клас. Покрита е и малко по-сложна математика, която
            е нужна за алгоритми, които ще разгледаме по-нататък.
        ';
        $expanded = '
            В тази секция ще разгледаме относително проста теория по математика, като например какво е просто число,
            как ефективно да проверяваме дали число е просто, как бързо да намираме простите числа в интервал (решето
            на Ератостен). Накратко са покриват неща като елементарна комбинаторика, какво са факториел и пермутация,
            най-малко общо кратно и най-голям общ делител. Ако не сте запознати, добре е да видите как работят двоичните
            числа и как да ги манипулирате чрез побитови операции. Тук е добре да разгледате как работи модулната
            аритметика, тъй като тя ще ви трябва за много задачи по-нататък.
            <br>
            Малко по-сложна теория включва умножение на матрици, бързо вдигане на степен (на числа и на матрици),
            деление по модул, функция на Ойлер и други. В секция по-нататък ще разгледаме и малко по-сложна математика,
            като например комбинаторика и вероятности.
            <br><br>
            Подходящи теми, които можете да прочетете, са
            <a href="http://www.informatika.bg/lectures/primes" target="_blank">Прости числа и факторизация</a>,
            <a href="http://www.informatika.bg/lectures/bitwise-operations" target="_blank">Побитови операции</a>,
            <a href="http://www.informatika.bg/lectures/modular-arithmetic" target="_blank">Модулна аритметика</a>,
            <a href="http://www.informatika.bg/lectures/fast-exponentiation" target="_blank">Бързо степенуване</a>,
            <a href="http://www.informatika.bg/lectures/gcd-and-lcm"
            target="_blank">Най-голям общ делител и най-малко общо кратно</a>,
            <a href="http://www.informatika.bg/lectures/long-numbers" target="_blank">Дълги числа</a>,
            <br><br>
            Повечето задачи в секцията се решават с елементарна математика. Изключение правят
            <a href="/problems/92">Euleonora Pt.1</a> и <a href="/problems/93">Euleonora Pt.2</a>, които изискват да
            знаете какво е <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" target="_blank">функция
            на Ойлер</a>. Една от задачите (<a href="/problems/4">8-Bit</a>) вече разгледахме в секцията за bruteforce,
            като тук можете да пробвате да напишете значително по-ефективното (но малко по-сложно) решение, базирано на
            комбинаторика.
        ';
        $problems = '225,24,228,187,201,140,156,192,92,93,4,172';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initSIDS($position) {
        $brain = new Brain();
        $key = 'SIDS';
        $link = 'simple-data-structures';
        $title = 'Simple Data Structures';
        $summary = '
            Секцията покрива най-основните структури данни: префиксен масив, динамичен масив, опашка, стек, свързан
            списък, и приоритетна опашка. Задачите тук изискват да се приложи умно една от тези стуктури за се постигне
            достатъчно ефективно решение.
        ';
        $expanded = '
            В тази секция ще разгледаме какво е структура данни и най-основните от тях: префиксен масив, динамичен
            масив (също наричан "vector"), стек, опашка, свързан списък, и приоритетна опашка. В повечето случаи няма
            да се налага да си ги пишете сами (тъй като са имплементирани в стандартните библиотеки на повечето езици).
            Все пак е хубаво да знаете как те са имплементирани и работят, както и какви са сложностите на операциите
            им, от една страна да не ги ползвате като "черна кутия", а от друга - защото в някои задачи се ползва само
            част от идеята им. Префиксният масив е значително по-рядко срещан в практическото програмиране, в следствие
            на което не е включен в стандартната библиотека. За сметка на това, както ще видим, има доста състезателни
            задачи, в които се ползва. Повечето от тези структури ще ползваме като част от алгоритми, които ще
            разгледаме по-нататък (например опашка при търсене в ширина и приоритетна опашка в алгиритъма на Дейкстра).
            <br><br>
            Подходящи теми, които можете да видите, са
            <a href="http://www.informatika.bg/lectures/data-structures" target="_blank">Структури данни</a>,
            <a href="http://www.informatika.bg/lectures/prefix-array" target="_blank">Префиксен масив</a>,
            <a href="http://www.informatika.bg/lectures/vector" target="_blank">Динамичен масив</a>,
            <a href="http://www.informatika.bg/lectures/list" target="_blank">Списък</a>,
            <a href="http://www.informatika.bg/lectures/queue" target="_blank">Опашка</a>,
            <a href="http://www.informatika.bg/lectures/stack" target="_blank">Стек</a>,
            <a href="http://www.informatika.bg/lectures/priority-queue" target="_blank">Приоритетна опашка</a>.
            Разбира се, за да не се налага да ги пишете всеки път, ще ви е полезно и да знаете как да ги ползвате
            от <a href="http://www.informatika.bg/lectures/STL" target="_blank">стандартната библиотека</a>.
            <br><br>
            Задачите в секцията са такива, че да не можете да ползвате наготово вградените в STL имплементации.
            В повечето се ползва само идея от някоя от структурите, или операция, която стандартно не се поддържа.
            В задачата <a href="/problems/129">Sum of Primes</a> ще можете да упражните Решето на Ератостен, което
            трябва да сте разгледали в предходната тема.
        ';
        $problems = '125,129,20,40,124';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGRF1($position) {
        $brain = new Brain();
        $key = 'GRF1';
        $link = 'simple-graphs';
        $title = 'Simple Graphs';
        $summary = '
            Секцията покрива графи и базови алгоритми в графи: търсене в дълбочина и ширина, Дeйкстра, минимално
            покриващо дърво, непресичащи се множества, топологично сортиране, и разширяване на графа.
        ';
        $expanded = '
            В тази секция ще разгледаме може би най-фундаменталната тема в състезателното програмиране - а именно
            теория на графите. Ще научим как да представяме графи в паметта по няколко различни начина. Ще разгледаме
            основните алгоритми за обхождане и търсене в графи: търсене в ширина, търсене в дълбочина, и алгоритъма
            на Дейкстра. Ще видим какво е минимално покриващо дърво, непресичащи се множества, топологично сортиране.
            Ще видим и една техника, която помага не само в графови задачи: разширяване на графа.
            <br><br>
            Темите, които биха ви били полезни за тази секция са
            <a href="http://www.informatika.bg/lectures/graphs" target="_blank">Графи и представяне на графи</a>,
            <a href="http://www.informatika.bg/lectures/depth-first-search" target="_blank">Търсене в дълбочина</a>,
            <a href="http://www.informatika.bg/lectures/breadth-first-search" target="_blank">Търсене в ширина</a>, и
            <a href="http://www.informatika.bg/lectures/dijkstra" target="_blank">Алгоритъм на Дейкстра</a>,
            <br><br>
            Откъм задачи това е една от най-дългите секции, като повечето алгоритми са покрити от поне две задачи
            (а по-основните - дори от повече). В повечето задачи се изисква директна имплементация или съвсем дребна
            модификация.
        ';
        $problems = '114,122,115,147,151,158,177,180,12,27,99,100,104,83,87,78,121,133';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initBSTS($position) {
        $brain = new Brain();
        $key = 'BSTS';
        $link = 'binary-search';
        $title = 'Binary & Ternary Search';
        $summary = '
            Секцията покрива най-популярната форма на "Разделяй и Владей": двоично търсене, а както и неговата
            модификация - троично търсене - което решава проблема с намирането на екстремум на изпъкнала функция.
        ';
        $expanded = '
            В тази секция ще разгледаме един от най-фундаменталните и изучавани алгоритми: двоично търсене. Ще видим
            и какво представлява неговата малка модификация "троично търсене", която ни позволява да намерим максимума
            на функция, която първо нараства, след което достига търсения максимум, и после намалява (или обратно -
            да намерим минимума на функция, която първо намалява, стига до него, и после нараства). Макар и относително
            прости, те са едни от най-често грешените алгоритми, тъй като при невнимание често може да се стигне до
            off-by-one грешка. Когато се ползват за нецели числа пък трябва да се подходи по малко по-различен начин
            за да се избегне възникване на проблем в следствие на точността на числата с плаваща запетая.
            <br><br>
            Тъй като двоичното и троичното търсене сами по себе си са относително прости, най-често в състезателни
            задачи те биват комбинирани с някакъв друг алгоритъм. В следствие на това можете да ги срещнете както в
            много прости, така и в много сложни задачи - сложността ще се определя именно от този "допълнителен"
            алгоритъм, който трябва да се приложи.
            <br><br>
            Темата, която ще ви е безкрайно полезна тук е
            <a href="http://www.informatika.bg/lectures/binary-search" target="_blank">Двоично търсене</a>,
            но преди нея можете да погледнете и
            <a href="http://www.informatika.bg/lectures/divide-and-conquer" target="_blank">Разделяй и Владей</a>.
            <br><br>
            В тази секция задачите ще комбинират двоично търсене с някои от алгоритмите, които вече разгледахме -
            например итерация, алчен алгоритъм, графов алгоритъм, или проста структура данни. В секциите по-нататък ще
            видим задачи, в които двоичното търсене е комбинирано с по-сложни алгоритми (като например сложни структури
            данни, потоци, 2-SAT, хеширане, и други).
        ';
        $problems = '117,130,141,168,226,118,28,30,60,76,185,209,22';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initDPDP($position) {
        $brain = new Brain();
        $key = 'DPDP';
        $link = 'dynamic-programming';
        $title = 'Dynamic Programming';
        $summary = '
            Секцията покрива една от най-фундаменталните теми в състезателното програмиране - а именно, динамично
            оптимиране. Тук са включени само стандартни динамични (едномерни, двумерни, и многомерни), без различни
            специфични разновидности, които ще разгледаме по-нататък.
        ';
        $expanded = '
            В тази секция ще разгледаме друга много основна тема от състезателното програмиране - динамичното
            оптимиране. Ще видим как изглежда то в най-базовия му вид - без специфични "чупки" на стейта, които
            сме покрили по-нататък. Динамичното е начинът да е сведат експоненциални решения до полиномиални такива,
            без особена промяна в кода. Поради елегантността си те са лесни както за писане от състезател, така и за
            създаване. В следствие на това те са ужасно често срещани по състезания (може би покриват над 20% от
            задачите).
            <br><br>
            Една (относително дълга) тема, която ще ви е нужна за тази секция е
            <a href="http://www.informatika.bg/lectures/dynamic-programming-part1" target="_blank">Динамично оптимиране,
            част I</a>. Допълнително четиво, което също би ви било полезно тук е
            <a href="http://www.informatika.bg/lectures/dynamic-programming-tips-and-tricks" target="_blank">Трикове
            в динамичното оптимиране</a>.
            <br><br>
            Задачите в секцията включват едномерно, двумерно, и многомерно динамично. По-сложни динамични задачи с
            по-разчупен стейт (например битова маска) или по-сложни оптимизации (например със структури данни) ще бъдат
            разгледани в секциите по-нататък.
        ';
        $problems = '113,116,243,142,167,174,50,33,61,85,196,198,39,212,213,224,235';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initBUCK($position) {
        $brain = new Brain();
        $key = 'BUCK';
        $link = 'bucketing';
        $title = 'Bucketing';
        $summary = '
            Секцията покрива задачи, които се решават чрез разделяне на данните в определен брой купчини (наричани
            "buckets"). В състезателни задачи можете да срещнете тази техника както за съставяне на ефективен
            алгоритъм, така и за структура данни.
        ';
        $expanded = '
            В тази секция ще разгледаме една не толкова честа (в сравнение с предните две), но пък хитра техника за
            разделяне на данните, която би могла да бъде ползвана както за ускоряване на алгоритми, така и за създаване
            на структура данни за специфични проблеми. Най-чистата версия вече трябва да сте срещнали в секцията за
            сортиране под формата на Counting Sort. Генерализация на този подход ще разгледаме и по-късно, когато
            говорим за хеширане и хештаблици.
            <br><br>
            Включените задачи в секцията са относително малко, но всяка от тях изисква важно наблюдение как точно да
            се разделят елементите в бъкети (какви да бъдат бъкетите, колко големи да бъдат и т.н.). За задачата
            <a href="/problems/150">Popcounts</a> пробвайте да измислите сами решение с константна сложност (за питане)
            вместо да ползвате вградената в езика функция (която ползва процесорна инструкция за това).
            <br><br>
        ';
        $problems = '150,162,105,68';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initITDP($position) {
        $brain = new Brain();
        $key = 'ITDP';
        $link = 'iterative-dynamic-programming';
        $title = 'Iterative Dynamic Programming';
        $summary = '
            Секцията покрива малко по-сложни динамични задачи, в които решението трябва да се направи итеративно. Така
            може да се спести паметта от някое от измеренията, което е един от специфичните видове динамично оптимиране
            (с оптимизация на паметта).
        ';
        $expanded = '
            В тази секция ще разгледаме още задачи, решавани с динамично оптимиране. За разлика от миналата секция, в
            която разгледахме неговите най-базови варианти, тук задачите ще са малко по-специфични - освен да измислите
            стейта ще трябва да видите и как точно да попълните динамичната таблица, така че да не се налага да я
            държите цялата в паметта. Това е възможно като се попълва някое от измеренията слой по слой - тоест, ако
            имате измерение, което зависи единствено от предходния или следващия слой (+/- 1 в индексирането) за
            изчисляването на текущия. В този случай цялото измерение се свежда до само два слоя, което може да доведе
            до огромни подобрения в нужната памет (например от N на 2, тоест, например от таблица
            <code>dyn[N][M][K]</code> на таблица <code>dyn[2][M][K]</code>.
            <br><br>
            Подходяща тема, която можете да разгледате, е
            <a href="http://www.informatika.bg/lectures/dynamic-programming-part2" target="_blank">Динамично оптимиране, част II</a>.
            <br><br>
            Задачите в секцията изискват оптимизация на паметта, ползвайки итеративно динамично.
        ';
        $problems = '6,148,71,19,101,189';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initWIND($position) {
        $brain = new Brain();
        $key = 'WIND';
        $link = 'sliding-window';
        $title = 'Sliding Window';
        $summary = '
            Секцията покрива техниката "Плъзгащ се прозорец", която позволява по-ефективно справяне със задачи, в които
            трябва многократно да намираме едно и също нещо (например сума, или бройка на някакви специални елементи) в
            непрекъснат интервал от стойности, който се променя единствено чрез премахване октъм края на интервала и
            добавяне в началото.
        ';
        $expanded = '
            В тази секция ще разгледаме няколко задачи, решавани с метода на "плъзгащия се прозорец" ("Sliding Window").
            Тази техника е популярна както в състезателни задачи, така и в задачи от интервюта за работа (макар и там
            обикновено да са значително по-лесни). Основната идея е да се възползваме от това, че даден интервал, който
            ни интересува, се променя относително малко (при това - само в началото и края, но не и средните елементи).
            В този случай можем да ползваме някаква структура данни в която да пазим важната за нас информация от
            подинтервала и да поддържаме бързо питане за функцията, която ни интересува (например сума, брой на някакви
            специални елементи, или нещо друго). Обикновено това, че интервалът се променя относително малко, ни
            позволява да преизползваме някаква информация от предходните query-та или търсения, без да се налага да я
            изчисляваме наново. Това може драстично да оптимизира алгоритъма, като свежда сложността на части от
            наивната имплементация от линейна до логаритмична или дори константна.
            <br><br>
            Подходяща тема, която можете да разгледате, е
            <a href="http://www.informatika.bg/lectures/sliding-window" target="_blank">Плъзгащ се прозорец</a>.
            <br><br>
            Задачите в секцията имат наивно, бавно решение, и бързо решение, базирано на "плъзгащ се прозорец". Много
            състезатели ползват наивното решение за да тестват бързото (с малки "рандом" тестове).
        ';
        $problems = '25,146,65,193';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initBMDP($position) {
        $brain = new Brain();
        $key = 'BMDP';
        $link = 'bitmask-dynamic-programming';
        $title = 'Bitmask Dynamic Programming';
        $summary = '
            Секцията покрива понятието "битова маска" и как можем да я ползваме в специфични динамични задачи, в чиито
            стейт се пази кои обекти от дадено множество вече са били използвани и кои - не.
        ';
        $expanded = '
            В тази секция ще разгледаме какво представлява "битова маска" и как тя се ползва като измерение в стейта на
            динамични задачи. Това е една от най-популярните разновидности на динамичното оптимиране и е гарантирано, че
            рано или късно ще срещнете такива задачи в състезания. Маската не е задължително да е двоична (макар и това
            да е най-честия случай) - понякога може да е четвъртична (като за всеки елемент от множеството се пазят по
            два бита) или троична (в който случай трябва да кодираме стейта ръчно).
            <br><br>
            За тази секция ще ви е полезно да разгледате темата за
            <a href="http://www.informatika.bg/lectures/bitwise-operations" target="_blank">побитови операции</a> и,
            разбира се,
            <a href="http://www.informatika.bg/lectures/dynamic-programming-part3" target="_blank">Динамично оптимиране, част III</a>.
            <br><br>
            Задачите в секцията се решават с динамично оптимиране, като едно (или повече) от измеренията са битови маски
            или числа в троична/четвъртична бройна система.
        ';
        $problems = '57,183,51,75,223,47,202,54,233';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGAME($position) {
        $brain = new Brain();
        $key = 'GAME';
        $link = 'game-theory';
        $title = 'Game Theory';
        $summary = '
            Секцията покрива теория на игрите: какво е оптимална игра, минимакс стратегия, и Sprague-Grundy числа. Ще
            бъдат разгледани стандартни задачи, както и стандартни задачи с някакви усложнения, като например търсене
            на цикъл или ползване на динамично оптимиране.
        ';
        $expanded = '
            В тази секция ще разгледаме основите на "теория на игрите" в състезателното програмиране. Ще научим какво е
            "оптимална игра" и как можем да намерим победителя в такава. Ще покажем минимакс стратегии (в които искаме
            да максимизираме нашия резултат и да минимизираме този на противника). Ще застъпим и основната теория зад
            много от състезателните задачи: числата на Грунди, които също може да срещнете като SG числа или пък
            NIMbers (кръстени на играта NIM). Реално теорията отзад е доста сложна, но пък прилагането й (което всъщност
            ви интересува в повечето задачи) е относително просто. Макар и плашеща на пръв поглед, това е една що-годе
            лесна секция.
            <br><br>
            За минаването през секцията ще ви помогне темата
            <a href="http://www.informatika.bg/lectures/game-theory" target="_blank">Теория на игрите</a>.
            <br><br>
            Задачите в секцията ползват или minimax, или SG, или комбинация на предните две с някакъв друг алгоритъм.
        ';
        $problems = '49,136,56,91,98,216';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initADDS($position) {
        $brain = new Brain();
        $key = 'ADDS';
        $link = 'advanced-data-structures';
        $title = 'Advanced Data Structures';
        $summary = '
            Секцията покрива по-сложни структури данни, които не се учат в базовите курсове по структури данни:
            индексни дървета, сегментни дървета, интервални дървета, квадратична опашка, префиксно дърво, KD-дърво и
            други.
        ';
        $expanded = '
            В тази секция ще разгледаме няколко по-сложни структури данни, които решават специфични проблеми значително
            по-ефективно от алтернативните им наивни имплементации с други структури. Тези структури са интересни за
            изучаване, тъй като обикновено се базират на интересна идея, която може да се използва и при решаване на
            други проблеми.
            <br><br>
            Най-често срещаните от тях, които ще разгледаме тук са индексно (binary indexed tree) и сегментно дърво
            (segment tree), както и тяхната генерализация - интервално дърво (interval tree). Малко по-редки (в
            състезателни задачи), но пък популярни в проблеми от реалния живот са квадратичната опашка (tiered vector),
            префиксното дърво (TRIE) и KD-дървото (KD-tree) (като последното намира голямо приложение в 3D-графиката).
            <br><br>
            Теми, които можете да прочетете, са:
            <a href="http://www.informatika.bg/lectures/index-trees" target="_blank">Индексно дърво</a>,
            <a href="http://www.informatika.bg/lectures/segment-trees" target="_blank">Сегментно дърво</a>,
            <a href="http://www.informatika.bg/lectures/range-minimum-query" target="_blank">Минимум в интервал</a>,
            <a href="http://www.informatika.bg/lectures/tiered-vector" target="_blank">Квадратична опашка</a>, и
            <a href="http://www.informatika.bg/lectures/trie" target="_blank">Префиксно дърво</a>, и
            <a href="http://www.informatika.bg/lectures/kd-tree" target="_blank">KD-дърво</a>.
            <br><br>
            Задачите покриват само някои от изброените структури, като трябва да видите коя къде е приложима.
        ';
        $problems = '149,34,37,94,5';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initSTRI($position) {
        $brain = new Brain();
        $key = 'STRI';
        $link = 'strings';
        $title = 'Strings';
        $summary = '
            Секцията покрива работа със символни низове: алгоритъм на Кнут-Морис-Прат, хеширане и хештаблица,
            префиксен и суфиксен масив, алгоритъм на Ахо-Корасик, както и модифициране на вече разгледани структури
            данни за стрингове.
        ';
        $expanded = '
            В тази секция ще разгледаме как да работим ефективно със символни низове - намиране на повтарящи се такива,
            сравняване на подстрингове, намиране дали даден стринг се среща като подстринг в друг, и т.н. Ще разгледаме
            основните стрингови алгоритми - хеширане и Кнут-Морис-Прат - като и по-сложни приложения чрез структури
            данни: <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank">Хештаблица</a>,
            <a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank">Merkle Tree</a>,
            префиксно дърво (Trie) и суфиксно дърво, както и Ахо-Корасик.
            <br><br>
            Темите, които ще са ви полезни, за да се справите с повечето стрингови задачи, са:
            <a href="http://www.informatika.bg/lectures/knuth-morris-pratt" target="_blank">Алгоритъм на Кнут-Морис-Прат</a>,
            <a href="http://www.informatika.bg/lectures/hashing" target="_blank">Хеширане</a>,
            <a href="http://www.informatika.bg/lectures/hashtable" target="_blank">Хештаблица</a>,
            <a href="http://www.informatika.bg/lectures/trie" target="_blank">Префиксно Дърво</a>,
            <a href="http://www.informatika.bg/lectures/suffix-tree" target="_blank">Суфиксно Дърво</a>,
            <a href="http://www.informatika.bg/lectures/suffix-array" target="_blank">Суфиксен Масив</a>, и
            <a href="http://www.informatika.bg/lectures/aho-corasick" target="_blank">Алгоритъм на Ахо-Корасик</a>.
            <br><br>
            Тук се покриват относително малко от изброените алгоритми и структури данни, така че ако искате да се
            чувствате сигурни, е хубаво да погледнете и седните задачи:
            <a href="http://www.spoj.com/problems/SUB_PROB/" target="_blank">SUB_PROB</a>,
            <a href="http://www.spoj.com/problems/SARRAY/" target="_blank">SARRAY</a>,
            <a href="http://www.spoj.com/problems/PHONELST/" target="_blank">PHONELST</a>,
            <a href="http://www.spoj.com/problems/LCS/" target="_blank">LCS</a>.
        ';
        $problems = '52,36,110';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGEOM($position) {
        $brain = new Brain();
        $key = 'GEOM';
        $link = 'geometry';
        $title = 'Geometry';
        $summary = '
            Секцията покрива основни геометрични задачи в програмирането: намиране на разстояние, пресичане на права с
            друга права или окръжност, ротации, насочено лице, принадлежност на точка в многоъгълник и други. Ще видим
            също какво е и как се намира изпъкнала обвивка.
        ';
        $expanded = '
            В тази секция ще разгледаме как можем да направим основни неща от геометрията ползвайки програмиране. Ще
            припомним как се намира разстояние между точки, лице на многоъгълник, как се прави ротация на точка около
            друга точка. Ще видим какво е насочено лице на триъгълник и как можем да го ползваме за проверка от коя
            страна на някаква права е дадена точка. Ще покрием и относително чести под-задачи, като например проверка
            за пресичане на права с права и права с окръжност, както и намиране на пресечната точка. Ще видим как да
            проверим дали точка е във вътрешността на многоъгълник и как ефективно да намерим изпъкналата обвивка на
            множество от точки.
            <br><br>
            Полезни теми, които можете да погледнете тук са
            <a href="http://www.informatika.bg/lectures/geometry" target="_blank">Геометрия</a>, а както и
            <a href="http://www.informatika.bg/lectures/binary-search" target="_blank">Двоично Търсене</a> и
            <a href="http://www.informatika.bg/lectures/ternary-search" target="_blank">Троично Търсене</a>,
            които понякога можем да ползваме за да избегнем справянето с частни случаи, които възникват при някои
            геометрични задачи.
            <br><br>
            Задачите в секцията изискват само някои от изброените по-горе алгоритми, но по-нататък ще срещнем и други
            задачи, които включват останалите, като например
            <a href="/problems/73">Spectre</a>, <a href="/problems/8">Towers</a>, или <a href="/problems/205">Deathstars</a>.
        ';
        $problems = '10,161,154,14';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGRF2($position) {
        $brain = new Brain();
        $key = 'GRF2';
        $link = 'medium-graphs';
        $title = 'Medium Graphs';
        $summary = '
            Секцията покрива малко по-сложни графови алгоритми като например намиране на силно-свързани компоненти,
            артикулационни точки, най-близък общ родител, ойлерови пътища и цикли, и намиране на брой пътища чрез
            матрици.
        ';
        $expanded = '
            В секцията ще разгледаме още няколко алгоритъма в графи: намиране на силно-свързани компоненти,
            артикулационни точки, най-близък общ родител, ойлерови пътища и цикли. Ще видим и как можем да намерим броя
            пътища между два върха чрез вдигане на матрицата на съседство на дадена степен. Ще покажем как това може да
            бъде скрито в различни задачи, които понякога на пръв поглед дори не приличат на графови.
            <br><br>
            Темите, които ще ви трябват, са
            <a href="http://www.informatika.bg/lectures/strongly-connected-components" target="_blank">Силно-свързани компоненти</a>,
            <a href="http://www.informatika.bg/lectures/eulerian-paths-and-cycles" target="_blank">Ойлерови пътища и цикли</a>,
            <a href="http://www.informatika.bg/lectures/lowest-common-ancestor" target="_blank">Най-близък общ родител</a>, и
            <a href="http://www.informatika.bg/lectures/tasks-solved-by-matrices" target="_blank">Задачи, решавани с матрици</a>.
            <br><br>
            Освен изброените по-горе неща, в задачите в темата сме включили и графи, които използват няколко неща,
            които показахме по-рано (например битови маски и разширяване на графа).
        ';
        $problems = '163,13,59,62,9,188,239';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initMITM($position) {
        $brain = new Brain();
        $key = 'MITM';
        $link = 'meet-in-the-middle';
        $title = 'Meet in the Middle';
        $summary = '
            Секцията покрива едно красиво приложение на техниката "Разделяй и Владей" - така нареченото "срещане в
            средата" или "meet-in-the-middle". С него можем да намалим на половина степента на някои задачи с
            експоненциална сложност.
        ';
        $expanded = '
            В секцията ще разгледаме техниката "meet-in-the-middle", която е разновидност на "разделяй и владей". За
            разлика от стандартните алгоритми, базирани на "разделяй и владей", meet-in-the-middle не може да се
            приложи рекурсивно, но пък обикновено се съчетава с някоя фенси структура данни или трябва някакво
            интересно наблюдение за да се стигне до достатъчно ефективно решение. В следствие на това повечето задачи,
            които се решават с meet-in-the-middle са доста "красиви" - балансират мисленето с коденето (имат както хитра
            идея, така и нетривиална (но не и ужасно сложна) имплементация).<br>
            Интересно приложение в реалния свят на тази техника е като
            <a href="https://en.wikipedia.org/wiki/Meet-in-the-middle_attack" target="_blank">криптографска атака</a>
            срещу криптирания, разчитащи на последователност от операции, приложени една след друга.
            <br><br>
            Единствената тема, която трябва да разгледате за да се справите с тази секция, е
            <a href="http://www.informatika.bg/lectures/meet-in-the-middle" target="_blank">Срещане в средата</a>.
            <br><br>
            Всички задачи в темата ползват под един или друг вид meet-in-the-middle подхода, като ползват различни
            структури данни за "комбиниране" на двете части.
        ';
        $problems = '80,207,79,3,11';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initPROB($position) {
        $brain = new Brain();
        $key = 'PROB';
        $link = 'probability';
        $title = 'Probability';
        $summary = '
            Секцията покрива темата вероятности, която се оказва относително добре застъпена в състезателната
            информатика. Тук разглеждаме различни начини, по които можем да подходим: ползвайки математика,
            динамично оптимиране, или в някои случаи дори геометрия.
        ';
        $expanded = '
            В секцията ще разгледаме няколко основни типа задачи за вероятности, които можем да срещнем в задачи по
            информатика. Трите най-основни "жанра" са:
            <ol>
                <li>Такива, които се решават с математика (стандартни формули и изчисления)</li>
                <li>Такива, които се решават с динамично оптимиране</li>
                <li>Такива, които се решават по геометричен начин</li>
            </ol>
            От трите може би най-скучният тип е първият (тъй като обикновено са почти чиста задача по математика, която
            е дадена да се имплементира на компютър). Вторите са интересни, като при това обикновено са лесни (тъй като
            стейтът често е очевиден или поне не е особено сложен). Третите са може би най-креативните, тъй като
            трябва да се досетите как да представите полето на възможностите геометрично и да намерите
            разстоянието/площта/обема от фигурата, които покриват нещата, които ви интересуват.
            <br><br>
            Темата, която би ви свършила работа е
            <a href="http://www.informatika.bg/lectures/probability" target="_blank">Вероятности</a>, като можете да
            си припомните и
            <a href="http://www.informatika.bg/lectures/dynamic-programming-part1" target="_blank">Динамично оптимиране, част I</a>.
            <br><br>
            Задачите в секцията са предимно от втория и третия вид, тъй като това са по-информатичните видове
            задачи за вероятности в състезателното програмиране.
        ';
        $problems = '227,84,131,210,211,135,48,97,41,26,89';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initINNR($position) {
        $brain = new Brain();
        $key = 'INNR';
        $link = 'inner-cycle-optimization';
        $title = 'Inner Cycle Optimization';
        $summary = '
            Секцията покрива "оптимизация на вътрешния цикъл" - трик, в който се ползва структура данни, алгоритъм,
            или неочевидно наблюдение за да се "премахне" най-вътрешния цикъл от наивната имплементация, като сложността
            на тази част се оптимизира до O(log) или понякога дори до О(1).
        ';
        $expanded = '
            В тази секция ще разгледаме така наречената "оптимизация на вътрешния цикъл". Тя всъщност не е изобщо
            алгоритъм или нещо, което можете да "научите" как се прави, тъй като в различни задачи бива приложена по
            различен начин. Главната идея е да напишете наивно решение (или понякога не наивно, но все пак бавно), и
            да премахнете най-вътрешния цикъл на изчисленията, заменяйки го с една единствена операция (ползване на
            вече изчислена стойност, обхождане на елементите единствено по изпъкналата обвивка на някаква функция, или
            взимане на елемент от структура данни - опашка, стек, пирамида, индексно дърво или всъщност всякаква друга).
            Така оптимизирате бързодействието на решението си многократно (от O(X*N) на O(X), или на O(X*logN)).
            Сложното в този тип задачи е да се сетите каква структура данни да ползвате (и как), или да направите
            някакво наблюдение как можете да ползвате вече намерени стойности.
            <br><br>
            Тук би ви била полезна темата за
            <a href="http://www.informatika.bg/lectures/segment-trees" target="_blank">Сегментни Дървета</a>.
            <br><br>
            В задачите в секцията не са покрити всички варианти на тази оптимизация (например ползване на изпъкнала
            обвивка), като се набляга по-скоро на ползването на структура данни за оптимизация.
        ';
        $problems = '107,38,21,137,82,204';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initSWLN($position) {
        $brain = new Brain();
        $key = 'SWLN';
        $link = 'sweep-line';
        $title = 'Sweep Line';
        $summary = '
            Секцията покрива "метода на замитащата права", която позволява по-ефективно справяне със задачи, в които
            имаме много заявки за неща, случващи се в произволни отрязъци от някакво измерение (време, пространство,
            или произволно наредимо множество) и няма значение реда на изпълнението.
        ';
        $expanded = '
            В тази секция ще разгледаме няколко задачи, решавани по "метода на замитащата права" ("Sweep Line"). Идеята
            на метода се базира на това да се възползваме от факта, че редът, в който изпълняваме зачвките няма значение
            и можем да го "променим" в по-удобен за нас начин. Обикновено това ни позволява да използваме някаква
            структура данни, в която да поддържаме информацията, която ни трябва, за отговарянето на "подредените"
            заявки. Това може драстично да оптимизира алгоритъма, като свежда сложността на части от имплементацията от
            линейна до логаритмична или дори константна. Този метод е тясно свързан с техниката на "плъзгащия се
            прозорец", която разгледахме по-рано (а както ще забележите - и задачите са донякъде подобни).
            <br><br>
            Подходяща тема, която можете да разгледате, е
            <a href="http://www.informatika.bg/lectures/sweep-line" target="_blank">Метод на замитащата права</a>.
            <br><br>
            Всички задачи включват някакъв вид заявки или обекти/неща, които искаме да изследваме, които няма проблем
            да сортираме и обходим в желан от наш ред. Какъв е този ред зависи от задача до задача и е нещо, което вие
            трябва да измислите. Както и при плъзгащия се прозорец, за повечето задачи съществува лесно "наивно"
            решение, с което можете да тествате бързото си такова.
        ';
        $problems = '32,69,73,46';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initADDP($position) {
        $brain = new Brain();
        $key = 'ADDP';
        $link = 'advanced-dynamic-programming';
        $title = 'Advanced Dynamic Programming';
        $summary = '
            Секцията покрива по-сложни задачи, решавани с динамично оптимиране - такива, в които трябва да се направи
            някакво неочевидно наблюдение за стигане до достатъчно ефективен стейт, или пък динамичното е съчетано
            с друга техника (например разделяй и владей, геометрия, или алчен алгоритъм).
        ';
        $expanded = '
            В тази секция ще разгледаме още няколко задачи от динамичното оптимиране, които обаче съвсем не са
            тривиални. За тяхното решаване е нужно да бъде направено неочевидно наблюдение или пък да се съчетае
            с друга стандартна техника от вече разгледаните до тук. Този тип задачи са изключително популярни в много
            от ученическите а и студентските състезания, поради относително кратката си имплементация, но все пак
            висока сложност.
            <br><br>
            Подходяща тема за тази секция е
            <a href="http://www.informatika.bg/lectures/dynamic-programming-part4" target="_blank">Динамично oптимиране, част IV</a>.
            <br><br>
            Задачите в тази секция изискват хитри наблюдения за да може стейтът да бъде достатъчно компактен за
            ограниченията на задачите. Изключение прави задачата <a href="/problems/17">Crypto</a>, която пък е сложна
            поради големите стойности, които може да бъде отговорът (за решаването й трябва да имплементирате някои от
            по-простите функции на
            <a href="http://www.informatika.bg/lectures/long-numbers" target="_blank">дълги числа</a>).
        ';
        $problems = '231,152,159,23,17,31,44,103,241';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initGRF3($position) {
        $brain = new Brain();
        $key = 'GRF3';
        $link = 'advanced-graphs';
        $title = 'Advanced Graphs';
        $summary = '
            Секцията покрива сложни алгоритми в графи, като например оптимално двойкосъчетание, потоци, 2-SAT,
            Унгарски алгоритъм, и потоци с минимална цена. Задачите не са тривиални дори ако знаете въпросните
            алгоритми, тъй като трябва да се досетите как да ги ползвате.
        ';
        $expanded = '
            В тази секция ще наблегнем на няколко от по-сложните алгоритми в графи - намиране на оптимално
            двойкосъчетание ("matching"), потоци ("maximum flows"), удовлетворяване на булев израз ("2-SAT"),
            така наречения Унгарски Алгоритъм, който се справя със задачата за разпределението
            ("assignment problem"), и дори ще зачекнем максимални потоци с минимална цена ("Min-cost Max-flow").
            Идеята (а и имплементацията, в някои случаи) на тези алгоритми не е тривиална, и всъщност броят
            програмисти, които могат да ги напишат без помощта на интернет или книга е много малък (под 1%).
            Както ще видите, с тях обаче могат да се зададат доста интересни задачи, в които самото досещане,
            че може да се ползва някой от тези алгоритми е относително сложно.
            <br><br>
            Теми, които биха ви помогнали за тази секция, са
            <a href="http://www.informatika.bg/lectures/matching" target="_blank">Оптимално двойкосъчетание</a>,
            <a href="http://www.informatika.bg/lectures/maximum-flow" target="_blank">Максимални потоци</a>,
            <a href="http://www.informatika.bg/lectures/2-sat" target="_blank">Удовлетворяване на булеви изрази</a>,
            <a href="http://www.informatika.bg/lectures/hungarian-algorithm" target="_blank">Унгарски алгоритъм</a>, и
            <a href="http://www.informatika.bg/lectures/min-cost-max-flow" target="_blank">Потоци с минимална цена</a>.
            <br><br>
            Голяма част от задачите в секцията се решават с мачинг или поток, но има и няколко, които са с някои
            от другите.
        ';
        $problems = '139,88,7,18,126,29,35,8,205,160,219,169,176,70';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initVARI($position) {
        $brain = new Brain();
        $key = 'VARI';
        $link = 'various';
        $title = 'Various';
        $summary = '
            Секцията покрива задачи, които не са със специфична тематика ("Ad-hoc" задачи) или пък такива, които
            съчетават няколко различни техники или алгоритми. Тук сме включили и задачи, за които решението е добре
            скрито и не искаме да ви разваляме удоволствието да го намерите =)
        ';
        $expanded = '
            В тази секция сме събрали задачи от различни тематики, но най-вече такива, които изискват специфично
            решение (не се решават с никой конкретен алгоритъм или техника). Включили сме и няколко задачи, които пък
            изискват съчетаването на няколко от разгледаните техники, алгоритми, или структури данни.
            <br><br>
            Сред задачите има и няколко, които се опитват да ви подведат да ползвате по-сложен алгоритъм, отколкото е
            нужно. Макар и да могат да бъдат решени от алгоритмите, които мимикрират, имплементацията им на състезание
            би ви загубили много ценно време.
        ';
        $problems = '42,242,111,173,186,108,197,77,96,86,64,237';
        $brain->addTopic($position, $key, $link, $title, $summary, $expanded, $problems);
    }

    private function initTraining() {
        // Group D
        $this->initIMPL(1);
        $this->initCCAS(2);
        $this->initRECU(3);
        $this->initBRUT(4);
        $this->initSORT(5);

        // Group C
        $this->initGRDY(6);
        $this->initMATH(7);
        $this->initSIDS(8);
        $this->initGRF1(9);
        $this->initBSTS(10);
        $this->initDPDP(11);
        $this->initBUCK(12);

        // Group B
        $this->initITDP(13);
        $this->initWIND(14);
        $this->initBMDP(15);
        $this->initGAME(16);
        $this->initADDS(17);
        $this->initSTRI(18);
        $this->initGEOM(19);
        $this->initGRF2(20);

        // Group A
        $this->initMITM(21);
        $this->initPROB(22);
        $this->initINNR(23);
        $this->initSWLN(24);
        $this->initADDP(25);
        $this->initGRF3(26);
        $this->initVARI(27);
    }

    private function getSection($key) {
        $brain = new Brain();
        $submits = $brain->getAllSubmits('AC');
        $topic = $brain->getTopic($key);
        $problemIds = explode(',', $topic['problems']);

        $sectionInfo = inBox('<h1>' . $topic['title'] . '</h1>' . $topic['expanded']);
        $sectionProblems = '';
        $problemClass = new ProblemsPage($this->user);
        foreach ($problemIds as $problemId) {
            $problemInfo = $brain->getProblem($problemId);
            $problemSubmits = $brain->getProblemSubmits($problemId, $GLOBALS['STATUS_ACCEPTED']);
            $sectionProblems .= $problemClass->getProblemBox($problemInfo, $problemSubmits);
        }
        return $sectionInfo . $sectionProblems;
    }

    private function getTopicStats($key) {
        $brain = new Brain();
        $topic = $brain->getTopic($key);
        $problems = explode(',', $topic['problems']);
        $solved = $brain->getSolved($this->user->id);
        $accepted = array_filter($solved, function($el) use ($problems) {return in_array($el, $problems);});
        $parentId = 'topic-stats-' . $key;
        return '<script>circularProgress(\'' . $parentId . '\', ' . count($accepted) . ', ' . count($problems) . ');</script>';
    }

    private function getTopicBox($topic) {
        $box = inBox('
            <div class="training-list-entry">
                <div class="training-list-text">
                    <h2>' . $topic['title'] . '</h2>
                    ' . $topic['summary'] . '
                </div>
                <div class="training-list-progress" id="topic-stats-' . $topic['key'] . '">
                    ' . $this->getTopicStats($topic['key']) . '
                </div>
            </div>
        ');
        return '<a href="/training/' . $topic['link'] . '" class="decorated">' . $box . '</a>';
    }

    private function getTopics() {
        $brain = new Brain();
        $topics = $brain->getTrainingTopics();

        $content = '';
        foreach ($topics as $topic) {
            $content .= $this->getTopicBox($topic);
        }
        return $content;
    }

    private function getMainInfo() {
        return inBox('
            <h1>Подготовка</h1>
            Тук можете да навлезете в света на състезателната информатика като учите и тренирате върху задачи, групирани
            по теми, в нарастваща сложност. Темите са така подредени, че да изискват само материал, който е покрит в
            по-предни. Разбира се, очаква се да можете да владеете основи на програмирането (на C++, Java, или Python),
            което включва как да стартирате програма, вход и изход, типове данни, променливи, масиви, условни оператори,
            и цикли.
            <br><br>
            В случай, че сте състезател или подготвяте състезатели, ориентировъчно темите са подходящи за следните групи:
            <ul>
                <li>
                    <a href="/training/implementation">Implementation</a>,
                    <a href="/training/corner-cases">Corner Cases</a>,
                    <a href="/training/recursion-and-backtrack">Recursion & Backtrack</a>,
                    <a href="/training/bruteforce">Bruteforce</a>, и
                    <a href="/training/sorting">Sorting</a>
                    са подходящи за ученици от D група и нагоре.
                </li>
                <li>
                    <a href="/training/greedy">Greedy</a>,
                    <a href="/training/math">Math</a>,
                    <a href="/training/simple-data-structures">Simple Data Structures</a>,
                    <a href="/training/simple-graphs">Simple Graphs</a>,
                    <a href="/training/binary-search">Binary/Ternary Search</a>,
                    <a href="/training/dynamic-programming">Dynamic Programming</a>,
                    <a href="/training/bucketing">Bucketing</a>
                    са подходящи за ученици от C група и нагоре.
                </li>
                <li>
                    <a href="/training/iterative-dynamic-programming">Iterative DP</a>,
                    <a href="/training/sliding-window">Sliding Window</a>,
                    <a href="/training/bitmask-dynamic-programming">Bitmask DP</a>,
                    <a href="/training/game-theory">Game Theory</a>,
                    <a href="/training/advanced-data-structures">Advanced Data Structures</a>,
                    <a href="/training/strings">Strings</a>,
                    <a href="/training/geometry">Geometry</a>, и
                    <a href="/training/medium-graphs">Medium Graphs</a>
                    са подходящи за ученици от B група и нагоре.
                </li>
                <li>
                    <a href="/training/meet-in-the-middle">Meet-in-the-Middle</a>,
                    <a href="/training/probability">Probability</a>,
                    <a href="/training/inner-cycle-optimization">Inner Cycle Optimization</a>,
                    <a href="/training/sweep-line">Sweep Line</a>,
                    <a href="/training/advanced-dynamic-programming">Advanced DP</a>, и
                    <a href="/training/advanced-graphs">Advanced Graphs</a>
                    са подходящи за ученици от А група.
                </li>
                <li>
                    <a href="/training/various">Various</a> задачите са предимно Ad-hoc или такива, съчетаващи няколко
                    различни теми.
                </li>
            </ul>
        ');
    }

    public function getContent() {
        // $this->initTraining();

        $content = '';
        if (!isset($_GET['section'])) {
            $content .= $this->getMainInfo();
            $content .= $this->getTopics();
        } else {
            $content .= $this->getSection($_GET['section']);
        }
        return $content;
    }

}

?>